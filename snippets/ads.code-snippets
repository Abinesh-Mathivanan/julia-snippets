{
    "Define a struct for a simple graph": {
        "prefix": "jl-graphstruct",
        "body": [
            "struct Graph",
            "    vertices::Vector{Int}",
            "    edges::Dict{Int, Vector{Int}}",
            "end"
        ],
        "description": "Defines a struct for a simple graph in Julia"
    },
    "Create a graph": {
        "prefix": "jl-addvertices",
        "body": [
            "# Create a graph",
            "g = Graph([1, 2, 3, 4, 5], Dict(1=>[], 2=>[], 3=>[], 4=>[], 5=>[]))",
            "add_edge(g, 1, 2)",
            "add_edge(g, 1, 3)",
            "add_edge(g, 2, 3)",
            "add_edge(g, 2, 4)",
            "add_edge(g, 3, 5)",
            "add_edge(g, 4, 5)"
        ],
        "description": "Creates a simple graph with vertices and edges in Julia"
    },
    "Function to add an edge between two vertices": {
        "prefix": "jl-addedgegraph",
        "body": [
            "function add_edge(graph::Graph, u::Int, v::Int)",
            "    push!(graph.edges[u], v)",
            "    push!(graph.edges[v], u)  # For undirected graph",
            "end"
        ],
        "description": "Defines a function to add an edge between two vertices in a graph"
    },
    "Add Edge": {
        "prefix": "jl-addedge",
        "body": [
            "function add_edge(graph::Graph, u::Int, v::Int)",
            "    push!(graph.edges[u], v)",
            "    push!(graph.edges[v], u)  # For undirected graph",
            "end"
        ],
        "description": "Adds an edge between two vertices in a graph"
    },
    "Add Vertex": {
        "prefix": "jl-addvertex",
        "body": [
            "function add_vertex(graph::Graph, v::Int)",
            "    if v not in graph.vertices",
            "        push!(graph.vertices, v)",
            "        graph.edges[v] = Int[]",
            "    end",
            "end"
        ],
        "description": "Adds a vertex to the graph if it doesn't already exist"
    },
    "Remove Edge": {
        "prefix": "jl-removeedge",
        "body": [
            "function remove_edge(graph::Graph, u::Int, v::Int)",
            "    deleteat!(graph.edges[u], findfirst(x -> x == v, graph.edges[u]))",
            "    deleteat!(graph.edges[v], findfirst(x -> x == u, graph.edges[v]))",
            "end"
        ],
        "description": "Removes an edge between two vertices in a graph"
    },
    "Remove Vertex": {
        "prefix": "jl-removevertex",
        "body": [
            "function remove_vertex(graph::Graph, v::Int)",
            "    delete!(graph.edges, v)",
            "    filter!(x -> x != v, graph.vertices)",
            "    for (u, neighbors) in graph.edges",
            "        deleteat!(neighbors, findfirst(x -> x == v, neighbors))",
            "    end",
            "end"
        ],
        "description": "Removes a vertex and its incident edges from the graph"
    },
    "Breadth-First Search (BFS) traversal": {
        "prefix": "jl-BFS",
        "body": [
            "function bfs(graph::Graph, start::Int, target::Int)",
            "    visited = falses(length(graph.vertices))",
            "    queue = [(start, 1)]  # Tuple: (node, index)",
            "    visited[start] = true",
            "",
            "    while !isempty(queue)",
            "        current, index = popfirst!(queue)",
            "        if current == target",
            "            return true, index",
            "        end",
            "        for neighbor in graph.edges[current]",
            "            if !visited[neighbor]",
            "                push!(queue, (neighbor, index + 1))",
            "                visited[neighbor] = true",
            "            end",
            "        end",
            "    end",
            "",
            "    return false, -1",
            "end"
        ],
        "description": "Defines a function for Breadth-First Search (BFS) traversal in a graph"
    },
    "Depth-First Search (DFS) traversal": {
        "prefix": "jl-DFS",
        "body": [
            "function dfs(graph::Graph, start::Int, target::Int)",
            "    visited = falses(length(graph.vertices))",
            "    stack = [(start, 1)]  # Tuple: (node, index)",
            "    visited[start] = true",
            "",
            "    while !isempty(stack)",
            "        current, index = pop!(stack)",
            "        if current == target",
            "            return true, index",
            "        end",
            "        for neighbor in reverse(graph.edges[current])",
            "            if !visited[neighbor]",
            "                push!(stack, (neighbor, index + 1))",
            "                visited[neighbor] = true",
            "            end",
            "        end",
            "    end",
            "",
            "    return false, -1",
            "end"
        ],
        "description": "Defines a function for Depth-First Search (DFS) traversal in a graph"
    },
    "Julia A* Search": {
        "prefix": "jl-A*",
        "body": [
            "using DataStructures",
            "",
            "function astar(start, goal, neighbors, heuristic)",
            "\tfrontier = PriorityQueue{Tuple{Float64, Any}}()",
            "\tfrontier[start] = 0",
            "\tcame_from = Dict{Any, Any}()",
            "\tcost_so_far = Dict{Any, Float64}()",
            "\tcame_from[start] = nothing",
            "\tcost_so_far[start] = 0",
            "",
            "\twhile !isempty(frontier)",
            "\t\tcurrent = dequeue!(frontier)",
            "",
            "\t\tif current == goal",
            "\t\t\tbreak",
            "\t\tend",
            "",
            "\t\tfor next in neighbors(current)",
            "\t\t\tnew_cost = cost_so_far[current] + 1",
            "\t\t\tif !haskey(cost_so_far, next) || new_cost < cost_so_far[next]",
            "\t\t\t\tcost_so_far[next] = new_cost",
            "\t\t\t\tpriority = new_cost + heuristic(goal, next)",
            "\t\t\t\tenqueue!(frontier, next, priority)",
            "\t\t\t\tcame_from[next] = current",
            "\t\t\tend",
            "\t\tend",
            "\tend",
            "",
            "\tpath = []",
            "\tcurrent = goal",
            "\twhile current != start",
            "\t\tpushfirst!(path, current)",
            "\t\tcurrent = came_from[current]",
            "\tend",
            "\tpushfirst!(path, start)",
            "",
            "\treturn path",
            "end",
            "",
            "# Usage: astar(start, goal, neighbors, heuristic)"
        ],
        "description": "Performs A* Search algorithm"
    },
    "Julia Uniform Cost Search": {
        "prefix": "jl-uniformcost",
        "body": [
            "using DataStructures",
            "",
            "function uniform_cost_search(start, goal, neighbors)",
            "\tfrontier = PriorityQueue{Tuple{Float64, Any}}()",
            "\tfrontier[start] = 0",
            "\tcame_from = Dict{Any, Any}()",
            "\tcost_so_far = Dict{Any, Float64}()",
            "\tcame_from[start] = nothing",
            "\tcost_so_far[start] = 0",
            "",
            "\twhile !isempty(frontier)",
            "\t\tcurrent = dequeue!(frontier)",
            "",
            "\t\tif current == goal",
            "\t\t\tbreak",
            "\t\tend",
            "",
            "\t\tfor next in neighbors(current)",
            "\t\t\tnew_cost = cost_so_far[current] + 1",
            "\t\t\tif !haskey(cost_so_far, next) || new_cost < cost_so_far[next]",
            "\t\t\t\tcost_so_far[next] = new_cost",
            "\t\t\t\tenqueue!(frontier, next, new_cost)",
            "\t\t\t\tcame_from[next] = current",
            "\t\t\tend",
            "\t\tend",
            "\tend",
            "",
            "\tpath = []",
            "\tcurrent = goal",
            "\twhile current != start",
            "\t\tpushfirst!(path, current)",
            "\t\tcurrent = came_from[current]",
            "\tend",
            "\tpushfirst!(path, start)",
            "",
            "\treturn path",
            "end",
            "",
            "# Usage: uniform_cost_search(start, goal, neighbors)"
        ],
        "description": "Performs Uniform Cost Search algorithm"
    },
    "Julia Best-First Search": {
        "prefix": "jl-BestFS",
        "body": [
            "using DataStructures",
            "",
            "function best_first_search(start, goal, neighbors, heuristic)",
            "\tfrontier = PriorityQueue{Tuple{Float64, Any}}()",
            "\tfrontier[start] = heuristic(goal, start)",
            "\tcame_from = Dict{Any, Any}()",
            "\tcame_from[start] = nothing",
            "",
            "\twhile !isempty(frontier)",
            "\t\tcurrent = dequeue!(frontier)",
            "",
            "\t\tif current == goal",
            "\t\t\tbreak",
            "\t\tend",
            "",
            "\t\tfor next in neighbors(current)",
            "\t\t\tif !haskey(came_from, next)",
            "\t\t\t\tenqueue!(frontier, next, heuristic(goal, next))",
            "\t\t\t\tcame_from[next] = current",
            "\t\t\tend",
            "\t\tend",
            "\tend",
            "",
            "\tpath = []",
            "\tcurrent = goal",
            "\twhile current != start",
            "\t\tpushfirst!(path, current)",
            "\t\tcurrent = came_from[current]",
            "\tend",
            "\tpushfirst!(path, start)",
            "",
            "\treturn path",
            "end",
            "",
            "# Usage: best_first_search(start, goal, neighbors, heuristic)"
        ],
        "description": "Performs Best-First Search algorithm"
    },
    "Dijkstra's algorithm for finding shortest path from m to n": {
        "prefix": "jl-dijkstras",
        "body": [
            "function dijkstra_shortest_path(graph::Graph, m::Int, n::Int)",
            "    n_vertices = length(graph.vertices)",
            "    dist = fill(Inf, n_vertices)  # Initialize distances to infinity",
            "    dist[m] = 0",
            "    visited = falses(n_vertices)",
            "",
            "    while !visited[n]",
            "        min_dist = Inf",
            "        min_index = -1",
            "",
            "        # Find the vertex with the smallest distance",
            "        for v in graph.vertices",
            "            if !visited[v] && dist[v] < min_dist",
            "                min_dist = dist[v]",
            "                min_index = v",
            "            end",
            "        end",
            "",
            "        # If all remaining vertices are at infinity or n vertex is visited, stop",
            "        if min_index == -1 || visited[n]",
            "            break",
            "        end",
            "",
            "        visited[min_index] = true",
            "",
            "        # Update distances to neighbors",
            "        for (v, weight) in graph.edges[min_index]",
            "            alt = dist[min_index] + weight",
            "            if alt < dist[v]",
            "                dist[v] = alt",
            "            end",
            "        end",
            "    end",
            "",
            "    shortest_path = [n]",
            "    current_vertex = n",
            "    while current_vertex != m",
            "        for (v, weight) in graph.edges[current_vertex]",
            "            if dist[current_vertex] == dist[v] + weight",
            "                pushfirst!(shortest_path, v)",
            "                current_vertex = v",
            "                break",
            "            end",
            "        end",
            "    end",
            "",
            "    return shortest_path, dist[n]",
            "end"
        ],
        "description": "Defines Dijkstra's algorithm for finding the shortest path from vertex m to vertex n in a graph"
    },
    "Prim's algorithm for finding minimum spanning tree": {
        "prefix": "jl-primsalgo",
        "body": [
            "function prim_mst(graph::Graph)",
            "    n_vertices = length(graph.vertices)",
            "    visited = falses(n_vertices)",
            "    mst = Graph([], Dict())",
            "",
            "    # Start from the first vertex",
            "    current_vertex = graph.vertices[1]",
            "    visited[current_vertex] = true",
            "    push!(mst.vertices, current_vertex)",
            "",
            "    while length(mst.vertices) < n_vertices",
            "        min_weight = Inf",
            "        min_edge = (0, 0)",
            "        for vertex in mst.vertices",
            "            for (neighbor, weight) in graph.edges[vertex]",
            "                if !visited[neighbor] && weight < min_weight",
            "                    min_weight = weight",
            "                    min_edge = (vertex, neighbor)",
            "                end",
            "            end",
            "        end",
            "        u, v = min_edge",
            "        push!(mst.vertices, v)",
            "        add_edge(mst, u, v, min_weight)",
            "        visited[v] = true",
            "    end",
            "",
            "    return mst",
            "end"
        ],
        "description": "Defines Prim's algorithm for finding the minimum spanning tree of a graph"
    },
    "Kruskal's algorithm for finding minimum spanning tree": {
        "prefix": "jl-kruskalalgo",
        "body": [
            "mutable struct UnionFind",
            "    parent::Vector{Int}",
            "    rank::Vector{Int}",
            "end",
            "",
            "function initialize_union_find(n::Int)",
            "    parent = collect(1:n)",
            "    rank = zeros(Int, n)",
            "    return UnionFind(parent, rank)",
            "end",
            "",
            "function find(uf::UnionFind, x::Int)",
            "    if uf.parent[x] != x",
            "        uf.parent[x] = find(uf, uf.parent[x])  # Path compression",
            "    end",
            "    return uf.parent[x]",
            "end",
            "",
            "function union_sets(uf::UnionFind, x::Int, y::Int)",
            "    root_x = find(uf, x)",
            "    root_y = find(uf, y)",
            "    if root_x == root_y",
            "        return",
            "    end",
            "    if uf.rank[root_x] < uf.rank[root_y]",
            "        uf.parent[root_x] = root_y",
            "    elseif uf.rank[root_x] > uf.rank[root_y]",
            "        uf.parent[root_y] = root_x",
            "    else",
            "        uf.parent[root_y] = root_x",
            "        uf.rank[root_x] += 1",
            "    end",
            "end",
            "",
            "function kruskal_mst(graph::Graph)",
            "    n_vertices = length(graph.vertices)",
            "    n_edges = length(graph.edges)",
            "    mst = Graph([], [])",
            "    uf = initialize_union_find(n_vertices)",
            "    sorted_edges = sort(graph.edges, by=x->x[3])",
            "",
            "    for (u, v, weight) in sorted_edges",
            "        if find(uf, u) != find(uf, v)",
            "            push!(mst.edges, (u, v, weight))",
            "            union_sets(uf, u, v)",
            "        end",
            "    end",
            "",
            "    return mst",
            "end"
        ],
        "description": "Defines Kruskal's algorithm for finding the minimum spanning tree of a graph"
    },
        "Define Stack": {
            "prefix": "jl-stackdefine",
            "body": [
                "struct Stack{T}",
                "\tdata::Vector{T}",
                "end",
                "",
                "function Stack{T}() where T",
                "\treturn Stack{T}(Vector{T}())",
                "end",
                ""
            ],
            "description": "Define Stack Data structure"
        },
        "Push Element onto Stack": {
            "prefix": "jl-stackpush",
            "body": [
                "push!(stack, $1)"
            ],
            "description": "Pushes an element onto the stack"
        },
        "Pop Element from Stack": {
            "prefix": "jl-stackpop",
            "body": [
                "pop!(stack)"
            ],
            "description": "Pops an element from the stack"
        },
        "Reverse Stack": {
            "prefix": "jl-stackrev",
            "body": [
                "reverse!(stack)"
            ],
            "description": "Reverses the order of elements in the stack"
        },
        "Infix to Postfix Conversion": {
            "prefix": "jl-inftopost",
            "body": [
                "function prec(c::Char)",
                "    if c == '^'",
                "        return 3",
                "    elseif c == '/' || c == '*'",
                "        return 2",
                "    elseif c == '+' || c == '-'",
                "        return 1",
                "    else",
                "        return -1",
                "    end",
                "end",
                "",
                "function associativity(c::Char)",
                "    if c == '^'",
                "        return 'R'",
                "    end",
                "    return 'L'",
                "end",
                "",
                "function infix_to_postfix(s::AbstractString)",
                "    result = Vector{Char}()",
                "    stack = Vector{Char}()",
                "",
                "    for c in s",
                "        if isletter(c) || isdigit(c)",
                "            push!(result, c)",
                "        elseif c == '('",
                "            push!(stack, c)",
                "        elseif c == ')'",
                "            while !isempty(stack) && last(stack) != '('",
                "                push!(result, pop!(stack))",
                "            end",
                "            pop!(stack)",
                "        else",
                "            while !isempty(stack) && (prec(c) < prec(last(stack)) ||",
                "                    (prec(c) == prec(last(stack)) && associativity(c) == 'L'))",
                "                push!(result, pop!(stack))",
                "            end",
                "            push!(stack, c)",
                "        end",
                "    end",
                "    while !isempty(stack)",
                "        push!(result, pop!(stack))",
                "    end",
                "",
                "    println(join(result))",
                "end",
                "",
                "# exp = \"a+b*(c^d-e)^(f+g*h)-i\"",
                "# infix_to_postfix(exp)"
            ],
            "description": "Converts an infix expression to postfix using the Shunting Yard algorithm"
        },
        "Prefix to Potfix Conversion": {
            "prefix": "jl-preftopost",
            "body": [
                "s = \"*-A/BC-/AKL\"",
                "",
                "stack = Vector{String}()",
                "operators = Set(['+', '-', '*', '/', '^'])",
                "s = reverse(s)",
                "for i in s",
                "    if i in operators",
                "        a = pop!(stack)",
                "        b = pop!(stack)",
                "        temp = b * a * i",
                "        push!(stack, temp)",
                "    else",
                "        push!(stack, i)",
                "    end",
                "end",
                "println(stack...)"
            ],
            "description": "Converts an infix expression to postfix"
        },
        "Define ListNode struct": {
            "prefix": "jl-singlynodestruct",
            "body": [
                "mutable struct ListNode{T}",
                "    value::T",
                "    next::Union{ListNode{T}, Nothing}",
                "end"
            ],
            "description": "Defines a mutable struct for a ListNode"
        },
        "Define SinglyLinkedList struct": {
            "prefix": "jl-singlystruct",
            "body": [
                "mutable struct SinglyLinkedList{T}",
                "    head::Union{ListNode{T}, Nothing}",
                "end"
            ],
            "description": "Defines a mutable struct for a SinglyLinkedList"
        },
        "Insert at the front of the SinglyLinkedList": {
            "prefix": "jl-insertfrontsingly",
            "body": [
                "function insert_front!(list::SinglyLinkedList{T}, value::T) where T",
                "    new_node = ListNode(value, list.head)",
                "    list.head = new_node",
                "end"
            ],
            "description": "Inserts a new node with the given value at the front of the SinglyLinkedList"
        },
        "Insert at the back of the SinglyLinkedList": {
            "prefix": "jl-insertbacksingly",
            "body": [
                "function insert_back!(list::SinglyLinkedList{T}, value::T) where T",
                "    new_node = ListNode(value, nothing)",
                "    if list.head === nothing",
                "        list.head = new_node",
                "        return",
                "    end",
                "    current = list.head",
                "    while current.next !== nothing",
                "        current = current.next",
                "    end",
                "    current.next = new_node",
                "end"
            ],
            "description": "Inserts a new node with the given value at the back of the SinglyLinkedList"
        },
        "Doubly Linked List Node Definition": {
            "prefix": "jl-doublynodestruct",
            "body": [
                "mutable struct DoublyListNode{T}",
                "\tvalue::T",
                "\tprev::Union{DoublyListNode{T}, Nothing}",
                "\tnext::Union{DoublyListNode{T}, Nothing}",
                "end"
            ],
            "description": "Defines a node for a doubly linked list"
        },
        "Doubly Linked List Definition": {
            "prefix": "jl-doublystruct",
            "body": [
                "mutable struct DoublyLinkedList{T}",
                "\thead::Union{DoublyListNode{T}, Nothing}",
                "\ttail::Union{DoublyListNode{T}, Nothing}",
                "end"
            ],
            "description": "Defines a doubly linked list"
        },
        "Insert Front Function for Doubly Linked List": {
            "prefix": "jl-insertfrontdoubly",
            "body": [
                "function insert_front!(list::DoublyLinkedList{T}, value::T) where T",
                "\tnew_node = DoublyListNode(value, nothing, list.head)",
                "\tif list.head !== nothing",
                "\t\tlist.head.prev = new_node",
                "\telse",
                "\t\tlist.tail = new_node",
                "\tend",
                "\tlist.head = new_node",
                "end"
            ],
            "description": "Inserts a new node at the front of a doubly linked list"
        },
        "Insert Back Function for Doubly Linked List": {
            "prefix": "jl-insertbackdoubly",
            "body": [
                "function insert_back!(list::DoublyLinkedList{T}, value::T) where T",
                "\tnew_node = DoublyListNode(value, list.tail, nothing)",
                "\tif list.tail !== nothing",
                "\t\tlist.tail.next = new_node",
                "\telse",
                "\t\tlist.head = new_node",
                "\tend",
                "\tlist.tail = new_node",
                "end"
            ],
            "description": "Inserts a new node at the back of a doubly linked list"
        },
        "Circular LinkedList Node": {
            "prefix": "jl-circularnodestruct",
            "body": [
                "mutable struct CircularListNode{T}",
                "\tvalue::T",
                "\tnext::Union{CircularListNode{T}, Nothing}",
                "end"
            ],
            "description": "Circular Linked List Node Definition"
        },
        "Circular LinkedList Definition": {
            "prefix": "jl-circularstruct",
            "body": [
                "mutable struct CircularLinkedList{T}",
                "\thead::Union{CircularListNode{T}, Nothing}",
                "\tlength::Int",
                "end"
            ],
            "description": "Circular Linked List Definition"
        },
        "Insert Front for Circular Linkedlist": {
            "prefix": "jl-insertfrontcircular",
            "body": [
                "function insert_front!(list::CircularLinkedList{T}, value::T) where T",
                "\tnew_node = CircularListNode(value, nothing)",
                "\tif list.head === nothing",
                "\t\tnew_node.next = new_node",
                "\t\tlist.head = new_node",
                "\telse",
                "\t\tnew_node.next = list.head.next",
                "\t\tlist.head.next = new_node",
                "\tend",
                "\tlist.length += 1",
                "end"
            ],
            "description": "Insert Front Function for Circular Linked List"
        },
        "InsertBackCircular": {
            "prefix": "jl-insertbackcircular",
            "body": [
                "function insert_back!(list::CircularLinkedList{T}, value::T) where T",
                "\tif list.head === nothing",
                "\t\tnew_node = CircularListNode(value, nothing)",
                "\t\tnew_node.next = new_node",
                "\t\tlist.head = new_node",
                "\telse",
                "\t\tnew_node = CircularListNode(value, list.head.next)",
                "\t\tlist.head.next = new_node",
                "\tend",
                "\tlist.length += 1",
                "end"
            ],
            "description": "Insert Back Function for Circular Linked List"
        },
        "Delete Node from Singly Linked List": {
            "prefix": "jl-deleteNodeSingly",
            "body": [
                "function delete_node!(head::Union{ListNode{T}, Nothing}, value::T) where T",
                "\tif head === nothing",
                "\t\treturn nothing",
                "\telseif head.value == value",
                "\t\treturn head.next",
                "\telse",
                "\t\tprev = head",
                "\t\tcurrent = head.next",
                "\t\twhile current !== nothing",
                "\t\t\tif current.value == value",
                "\t\t\t\tprev.next = current.next",
                "\t\t\t\tbreak",
                "\t\t\tend",
                "\t\t\tprev = current",
                "\t\t\tcurrent = current.next",
                "\t\tend",
                "\t\treturn head",
                "\tend",
                "end"
            ],
            "description": "Deletes a node by value from a singly linked list"
        },
        "Delete Node from Doubly Linked List": {
            "prefix": "jl-deleteNodeDoubly",
            "body": [
                "function delete_node!(head::Union{DoublyListNode{T}, Nothing}, value::T) where T",
                "\tif head === nothing",
                "\t\treturn nothing",
                "\telseif head.value == value",
                "\t\tnew_head = head.next",
                "\t\tif new_head !== nothing",
                "\t\t\tnew_head.prev = nothing",
                "\t\tend",
                "\t\treturn new_head",
                "\telse",
                "\t\tcurrent = head",
                "\t\twhile current !== nothing",
                "\t\t\tif current.value == value",
                "\t\t\t\tprev_node = current.prev",
                "\t\t\t\tnext_node = current.next",
                "\t\t\t\tprev_node.next = next_node",
                "\t\t\t\tif next_node !== nothing",
                "\t\t\t\t\tnext_node.prev = prev_node",
                "\t\t\t\tend",
                "\t\t\t\tbreak",
                "\t\t\tend",
                "\t\t\tcurrent = current.next",
                "\t\tend",
                "\t\treturn head",
                "\tend",
                "end"
            ],
            "description": "Deletes a node by value from a doubly linked list"
        },
        "Delete Node from Circular Linked List": {
            "prefix": "jl-deleteNodeCircular",
            "body": [
                "function delete_node!(head::Union{CircularListNode{T}, Nothing}, value::T) where T",
                "\tif head === nothing",
                "\t\treturn nothing",
                "\tend",
                "\tcurrent = head",
                "\twhile current.next !== head",
                "\t\tif current.next.value == value",
                "\t\t\tcurrent.next = current.next.next",
                "\t\t\treturn head",
                "\t\tend",
                "\t\tcurrent = current.next",
                "\tend",
                "\tif head.value == value",
                "\t\tif head.next === head",
                "\t\t\treturn nothing",
                "\t\tend",
                "\t\tcurrent = head",
                "\t\twhile current.next !== head",
                "\t\t\tcurrent = current.next",
                "\t\tend",
                "\t\tcurrent.next = head.next",
                "\t\thead = head.next",
                "\tend",
                "\treturn head",
                "end"
            ],
            "description": "Deletes a node by value from a circular linked list"
        }
}